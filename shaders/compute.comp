#version 450
#extension GL_ARB_shader_draw_parameters : enable

/*
* Step 5: "BVH Traversal"
* (count = -1) and (count = rightChildIndex)

*/

struct Vertex {
    vec3 pos;
    float pad;
};

struct Material {
    vec3 albedo;
    float type;
};

struct Ray {
    vec3 origin;
    vec3 dir;
};


struct LinearBVHNode {
    vec3 bbox_min;
    float pad1;
    vec3 bbox_max;
    float pad2;
    int data;
    int count;
};

// --- 2. BINDINGS ---
layout(rgba8, set = 0, binding = 0) uniform restrict writeonly image2D resultImage;

layout(std430, set = 0, binding = 1) buffer TriangleBuffer {
    Vertex vertices[];
} triBuf;

// 48 bytes
layout(std430, set = 0, binding = 2) buffer MaterialBuffer {
    Material materials[];
} matBuf;

layout(std430, set = 0, binding = 3) buffer BVHBuffer {
    LinearBVHNode nodes[];
} bvhBuf;

// --- 3. Push Constants ---
layout(push_constant) uniform Constants {
    int numTriangles;
} constants;

// --- 4. CONSTANTS & UTILITY ---
const float T_MIN = 0.001;
const float T_MAX = 10000.0;

vec3 ray_at(Ray r, float t) {
    return r.origin + r.dir * t;
}


// --- 5. INTERSECTION: AABB ---
bool hit_aabb(Ray r, vec3 bbox_min, vec3 bbox_max) {
    vec3 invDir = 1.0 / r.dir;
    vec3 t0s = (bbox_min - r.origin) * invDir;
    vec3 t1s = (bbox_max - r.origin) * invDir;

    vec3 tmin = min(t0s, t1s);
    vec3 tmax = max(t0s, t1s);

    float t_enter = max(max(tmin.x, tmin.y), tmin.z);
    float t_exit = min(min(tmax.x, tmax.y), tmax.z);

    return t_exit > t_enter && t_exit > T_MIN && t_enter < T_MAX;
}


// --- 6. INTERSECTION: TRIANGLE ---
bool hit_triangle(Ray r, vec3 v0, vec3 v1, vec3 v2, inout float closest_t) {
    vec3 edge1 = v1 - v0;
    vec3 edge2 = v2 - v0;
    vec3 ray_cross_e2 = cross(r.dir, edge2);
    float det = dot(edge1, ray_cross_e2);

    if (det > -0.00001 && det < 0.00001) return false;

    float inv_det = 1.0 / det;
    vec3 s = r.origin - v0;
    float u = inv_det * dot(s, ray_cross_e2);

    if (u < 0.0 || u > 1.0) return false;

    vec3 s_cross_e1 = cross(s, edge1);
    float v = inv_det * dot(r.dir, s_cross_e1);

    if (v < 0.0 || (u + v) > 1.0) return false;

    float t = inv_det * dot(edge2, s_cross_e1);
    if (t > T_MIN && t < closest_t) {
        closest_t = t;
        return true;
    } else {
        return false;
    }
}


// --- 7. MAIN SHADER ---
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

void main() {
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 image_size = imageSize(resultImage);

    if (pixel_coords.x >= image_size.x || pixel_coords.y >= image_size.y) {
        return;
    }

    // --- 7a. Calculate Ray ---
    float u_raw = float(pixel_coords.x) / float(image_size.x);
    float v_raw = float(image_size.y - 1 - pixel_coords.y) / float(image_size.y); // Y-flip

    vec3 origin = vec3(0.0, 0.0, 15.0);
    float vfov = 20.0;
    float aspect_ratio = float(image_size.x) / float(image_size.y);
    float theta = radians(vfov);
    float h = tan(theta / 2.0);
    float viewport_height = 2.0 * h;
    float viewport_width = aspect_ratio * viewport_height;
    float focus_dist = 10.0;

    vec3 w = normalize(origin - vec3(0,0,0));
    vec3 u = normalize(cross(vec3(0,1,0), w));
    vec3 v = cross(w, u);

    vec3 horizontal = focus_dist * viewport_width * u;
    vec3 vertical = focus_dist * viewport_height * v;
    vec3 lower_left_corner = origin - (horizontal / 2.0) - (vertical / 2.0) - focus_dist * w;

    Ray r;
    r.origin = origin;
    r.dir = normalize(
    (lower_left_corner + (horizontal * u_raw) + (vertical * v_raw)) - origin
    );

    // --- 7b. BVH Traversal (Düzeltilmiş Mantık) ---
    float closest_t = T_MAX;
    vec4 final_color = vec4(0.0, 0.0, 0.0, 1.0);
    bool hit_anything = false;
    int hit_triangle_index = -1;
    vec3 hit_normal = vec3(0,0,0);


    int stack[256];

    int stackPtr = 0;
    stack[stackPtr++] = 0;

    while (stackPtr > 0) {
        int nodeIndex = stack[--stackPtr];
        LinearBVHNode node = bvhBuf.nodes[nodeIndex];

        if (hit_aabb(r, node.bbox_min, node.bbox_max)) {

            if (node.count < 0) {

                int triangleIndex = -(node.data + 1);
                int currentTriIndex = triangleIndex; // (Şimdilik yaprakta 1 üçgen var)

                vec3 v0 = triBuf.vertices[currentTriIndex * 3 + 0].pos;
                vec3 v1 = triBuf.vertices[currentTriIndex * 3 + 1].pos;
                vec3 v2 = triBuf.vertices[currentTriIndex * 3 + 2].pos;

                float temp_t = closest_t;
                if (hit_triangle(r, v0, v1, v2, temp_t)) {
                    closest_t = temp_t;
                    hit_anything = true;
                    hit_triangle_index = currentTriIndex;
                    vec3 edge1 = v1 - v0;
                    vec3 edge2 = v2 - v0;
                    hit_normal = normalize(cross(edge1, edge2));
                }
            } else {
                int leftChildIndex = node.data;
                int rightChildIndex = node.count;

                stack[stackPtr++] = leftChildIndex;
                stack[stackPtr++] = rightChildIndex;
            }
        }
    }

    // --- 7c. Shading ---
    if (hit_anything) {
        Material mat = matBuf.materials[hit_triangle_index];
        vec3 light_dir = normalize(vec3(1, 1, 1));
        float light_intensity = max(0.0, dot(hit_normal, light_dir)) * 0.8 + 0.2;
        final_color = vec4(mat.albedo * light_intensity, 1.0);
    } else {
        final_color = vec4(0.0, 0.0, 0.0, 1.0); // Arka plan
    }

    // --- 7d. Write Color ---
    imageStore(resultImage, pixel_coords, final_color);
}